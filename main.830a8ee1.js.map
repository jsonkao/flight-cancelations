{"version":3,"sources":["vertices.js","shaders/borders.frag","shaders/borders.vert","shaders/texture.frag","shaders/texture.vert","main.js"],"names":["equirectangular_project","lon","lat","out","Float32Array","azimuth","Math","PI","inclination","y","sin","z","cos","compute_vertices","buffer","count","Uint32Array","indices","coords","length","vertices","v","i","len","a","j","b","push","module","exports","regl","base","getVertices","fetch","then","response","arrayBuffer","getTexture","filename","Promise","resolve","image","Image","src","crossOrigin","onload","texture","data","flipY","main","landTexture","monoTexture","all","spec","mono","drawBorders","frag","borderFrag","vert","borderVert","uniforms","aspectRatio","attributes","position","primitive","drawTexture","textureFrag","textureVert","tick","prop","frame","clear","color","depth","test","res","buf","console","log","Uint16Array","viewportWidth","viewportHeight","ar","catch","error"],"mappings":"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","file":"main.830a8ee1.js","sourceRoot":"..","sourcesContent":["function equirectangular_project(lon, lat) {\n  const out = new Float32Array(2);\n\n  const azimuth = lon * (Math.PI / 180);\n  const inclination = Math.PI / 2 - lat * (Math.PI / 180);\n\n  const y = Math.sin(inclination) * Math.sin(azimuth);\n  const z = Math.cos(inclination);\n\n  out[0] = y;\n  out[1] = z;\n\n  return out;\n}\n\nexport function compute_vertices(buffer) {\n  // First uint32 (4 bytes) contain the number of line strings.\n  const count = new Uint32Array(buffer, 0, 1)[0];\n  // Each of the next `count` uint32s stores the vertex count of a line string.\n  const indices = new Uint32Array(buffer, 4, count);\n  // Rest of bytes contain vertex coordinates (alternating long-lat pairs)\n  const coords = new Float32Array(buffer, 4 * (indices.length + 1));\n\n  const vertices = [];\n  let v = 0;\n\n  for (let i = 0; i < indices.length; i += 1) {\n    const len = indices[i];\n\n    let a = equirectangular_project(coords[v++], coords[v++]);\n\n    for (let j = 1; j < len; j += 1) {\n      const b = equirectangular_project(coords[v++], coords[v++]);\n\n      vertices.push(...a, ...b);\n\n      a = b;\n    }\n  }\n\n  return new Float32Array(vertices);\n}\n","module.exports=\"precision mediump float;\\n#define GLSLIFY 1\\n\\nvoid main() {\\n  gl_FragColor = vec4(vec3(220. / 255.), 1.);\\n}\\n\";","module.exports=\"precision mediump float;\\n#define GLSLIFY 1\\n\\nuniform vec2 aspectRatio;\\n\\nattribute vec2 position;\\n\\nvoid main() {\\n  gl_Position = vec4(position / aspectRatio, 0, 1);\\n}\\n\";","module.exports=\"#define PI 3.1415926538\\n\\nprecision mediump float;\\n#define GLSLIFY 1\\n\\nuniform sampler2D landTexture;\\nuniform sampler2D monoTexture;\\nuniform float tick;\\n\\nvarying vec2 v_position;\\n\\nvec3 LIGHT_REVERSED = vec3(-0.5, 0.5, 1);\\nfloat LIGHT_MAG = distance(LIGHT_REVERSED, vec3(0));\\n\\nvoid main() {\\n\\n  // Right now, we have v_position in [-1, 1] x [-1, 1]. Each fragment is\\n  // a point on the sphere. We have to figure out the long-lat from that point\\n  // to find the correct texture position.\\n  // First we take Cartesian coordinates.\\n\\n  float y = v_position.x;\\n  float z = v_position.y;\\n  float hyp_squared = y * y + z * z;\\n\\n  // 1. Discard points outside the sphere\\n\\n  if (sqrt(hyp_squared) > 1.) {\\n    discard;\\n  }\\n\\n  // 2. Determine front-facing spherical coordinate\\n\\n  float lambda_offset = tick / 400.;\\n\\n  float x = sqrt(1. - hyp_squared); // Take positive face\\n  float lambda = atan(y / x);       // [-PI / 2, PI / 2]\\n  float phi = PI / 2. - acos(z);    // [-PI / 2, PI / 2]\\n\\n  // 3. Convert long-lat radians to long-lat\\n\\n  float longitude = (lambda + PI) / (2. * PI); // map to [0, 0.5]\\n  float latitude = phi / PI + 0.5;             // map to [0, 1]\\n\\n  // 3.5. Draw lat/lng lines\\n\\n  // if (mod(longitude, PI / 360.) < 0.001) {\\n  //   gl_FragColor = vec4(0, 0, 0, 0.3);\\n  //   return;\\n  // }\\n\\n  // 4. Grab the texture color and do some color stuffs. Black = land, white =\\n  // no land.\\n\\n  vec2 longlat = vec2(mod(longitude, 1.), mod(latitude, 1.));\\n  vec3 texture_color = texture2D(landTexture, longlat).rgb;\\n  vec3 mono_color = texture2D(monoTexture, longlat).rgb;\\n\\n  texture_color += vec3(240. / 255.) * mono_color;\\n\\n  // 5. Calculate lighting. Allow it to only impact a little bit.\\n\\n  float dotted = dot(vec3(y, z, x), LIGHT_REVERSED) / LIGHT_MAG;\\n  float light = sign(dotted) * pow(dotted, 1.2);\\n  light = min(1.0, 0.55 + light * 0.3);\\n\\n  gl_FragColor = vec4(texture_color, 1.);\\n  gl_FragColor.rgb *= light;\\n}\\n\";","module.exports=\"precision mediump float;\\n#define GLSLIFY 1\\n\\nuniform vec2 aspectRatio;\\n\\nattribute vec2 position;\\n\\nvarying vec2 v_position;\\n\\nvoid main() {\\n  // For some reason textures only cover the first quadrant of the clip space.\\n  // Remember that v_position should become the coordinate of the texture in\\n  // clip space. Cutting position in half means that (1, 1) in the clip space\\n  // becomes (0.5, 0.5) on the texture.\\n  // two quadrants' worth of space.\\n  // Adding 0.5 to position means that (1, 1) in the clip space becomes (1, 1)\\n  // on the texture, and similarly (0, 0) -> (0.5, 0.5) (the texture's center)\\n  // and (-1, -1) -> (0, 0).\\n\\n  // v_position = 0.5 + position * 0.5;\\n  v_position = position * aspectRatio;\\n\\n  // gl_Position should be position because the position attribute covers the\\n  // whole clip space\\n  gl_Position = vec4(position, 0, 1);\\n}\\n\";","import createREGL from 'regl';\nimport { compute_vertices } from './vertices';\n\nimport borderFrag from './shaders/borders.frag';\nimport borderVert from './shaders/borders.vert';\nimport textureFrag from './shaders/texture.frag';\nimport textureVert from './shaders/texture.vert';\n\nimport spec from './specularity@2x.png';\nimport mono from './mono@2x.png';\n\nconst regl = createREGL();\n\nconst base =\n  'https://static01.nyt.com/newsgraphics/2020/02/04/coronavirus-flights/67d5b188d41684d2a82da11e94e358b4a769735e';\n\nasync function getVertices() {\n  return fetch(`${base}/geometry/borders.dat`)\n    .then(response => response.arrayBuffer())\n    .then(buffer => compute_vertices(buffer));\n}\n\nasync function getTexture(filename) {\n  return new Promise(resolve => {\n    const image = new Image();\n    // image.src = `${base}/textures/${filename}`;\n    image.src = filename;\n    image.crossOrigin = '';\n    image.onload = () => resolve(regl.texture({ data: image, flipY: true }));\n  });\n}\n\nasync function main() {\n  const [vertices, landTexture, monoTexture] = await Promise.all([\n    getVertices(),\n    // getTexture('specularity@2x.png'),\n    // getTexture('mono@2x.png'),\n    getTexture(spec),\n    getTexture(mono),\n  ]);\n\n  const drawBorders = regl({\n    frag: borderFrag,\n    vert: borderVert,\n\n    uniforms: {\n      aspectRatio,\n    },\n\n    attributes: {\n      position: vertices,\n    },\n\n    count: vertices.length / 2,\n    primitive: 'lines',\n  });\n\n  const drawTexture = regl({\n    frag: textureFrag,\n    vert: textureVert,\n\n    uniforms: {\n      landTexture,\n      monoTexture,\n      tick: regl.prop('tick'),\n      aspectRatio,\n    },\n\n    attributes: {\n      // Two triangles that cover the whole clip space\n      position: regl.buffer([\n        [-1, 1],\n        [1, -1],\n        [1, 1],\n        [-1, 1],\n        [1, -1],\n        [-1, -1],\n      ]),\n    },\n\n    count: 6,\n  });\n\n  regl.frame(({ tick }) => {\n    regl.clear({\n      color: [0, 0, 0, 0],\n      depth: 1,\n    });\n    drawBorders();\n    drawTexture({ tick });\n  });\n}\n\nasync function test() {\n  const res = await fetch(`${base}/20200123.dat`);\n  const buf = await res.arrayBuffer();\n  console.log(new Uint16Array(buf));\n}\n\nmain().catch(console.error);\n\nfunction aspectRatio({ viewportWidth, viewportHeight }) {\n  const ar = viewportWidth / viewportHeight;\n  return ar > 1 ? [ar, 1] : [1, 1 / ar];\n}\n"]}