{"version":3,"sources":["vertices.js","shaders/borders.frag","shaders/borders.vert","shaders/texture.frag","shaders/texture.vert","main.js"],"names":["project","lon","lat","out","Float32Array","lat_radians","Math","PI","lon_radians","x","sin","z","cos","y","tan","mag","sqrt","equirectangular_project","compute_vertices","buffer","count","Uint32Array","indices","coords","length","vertices","v","i","len","a","j","b","push","longs","lats","forEach","console","log","min","max","module","exports","regl","base","getVertices","fetch","then","response","arrayBuffer","getTexture","filename","Promise","resolve","image","Image","src","crossOrigin","onload","texture","main","landTexture","monoTexture","all","drawBorders","frag","borderFrag","vert","borderVert","attributes","position","primitive","drawTexture","textureFrag","textureVert","uniforms","tick","prop","aspectRatio","viewportWidth","viewportHeight","ar","frame","clear","color","depth","test","res","buf","Uint16Array","catch","error"],"mappings":"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","file":"main.6c018148.js","sourceRoot":"..","sourcesContent":["function project(lon, lat) {\n  const out = new Float32Array(2);\n\n  const lat_radians = (lat / 180) * Math.PI;\n  const lon_radians = ((lon + 90) / 180) * Math.PI;\n\n  let x = Math.sin(lon_radians);\n  let z = Math.cos(lon_radians);\n  let y = Math.tan(lat_radians);\n\n  const mag = Math.sqrt(1 + y * y);\n\n  x /= mag;\n  y /= mag;\n  z /= mag;\n\n  out[0] = x;\n  out[1] = y;\n  // out[2] = z;\n\n  return out;\n}\n\nfunction equirectangular_project(lon, lat) {\n  const out = new Float32Array(2);\n\n  const lon_radians = (lon + 90) * (Math.PI / 180);\n  const lat_radians = lat * (Math.PI / 180);\n\n  const x = Math.cos(lat_radians) * Math.cos(lon_radians);\n  const y = Math.sin(lat_radians);\n\n  out[0] = lon;\n  out[1] = lat;\n\n  return out;\n}\n\nexport function compute_vertices(buffer) {\n  // First 4 bytes contain the number of \"indices\"\n  // Each \"indices\" is a count of how many vertices are in a line.\n  const count = new Uint32Array(buffer, 0, 1)[0];\n  // Next 4 * count bytes stores the vertex counts\n  const indices = new Uint32Array(buffer, 4, count);\n  // Rest of bytes contain float coordinates (alternating lon-lat pairs)\n  const coords = new Float32Array(buffer, 4 * (indices.length + 1));\n\n  const vertices = [];\n  let v = 0;\n\n  // Constructing line strings. `indices` is a list of linestring sizes.\n  for (let i = 0; i < indices.length; i += 1) {\n    const len = indices[i];\n\n    let a = equirectangular_project(coords[v++], coords[v++]);\n\n    for (let j = 1; j < len; j += 1) {\n      const b = equirectangular_project(coords[v++], coords[v++]);\n\n      vertices.push(...a, ...b);\n\n      a = b;\n    }\n  }\n\n  let longs = [];\n  let lats = [];\n  vertices.forEach((v, i) => {\n    (i % 2 === 0 ? longs : lats).push(v);\n  });\n  console.log('longs', Math.min(...longs), Math.max(...longs));\n  console.log('lats', Math.min(...lats), Math.max(...lats));\n  return new Float32Array(vertices);\n}\n","module.exports=\"precision mediump float;\\n#define GLSLIFY 1\\n\\nuniform float time;\\n\\nvoid main() {\\n  // rotate2d(sin(time) * PI)\\n  gl_FragColor = vec4(1, 0, 0, 1);\\n}\\n\";","module.exports=\"precision mediump float;\\n#define GLSLIFY 1\\n\\nattribute vec2 position;\\n\\nvoid main() {\\n  gl_PointSize = 3.;\\n  gl_Position = vec4(position, 0, 1);\\n}\\n\";","module.exports=\"#define PI 3.1415926538\\n\\nprecision mediump float;\\n#define GLSLIFY 1\\n\\nuniform sampler2D landTexture;\\nuniform sampler2D monoTexture;\\nuniform float tick;\\n\\nvarying vec2 v_position;\\n\\nvec3 LIGHT_REVERSED = vec3(-1, 1, 1);\\nfloat LIGHT_MAG = distance(LIGHT_REVERSED, vec3(0));\\n\\nvoid main() {\\n\\n  // Right now, we have v_position in [-1, 1] x [-1, 1]. Each fragment is\\n  // a point on the sphere. We have to figure out the long-lat from that point\\n  // to find the correct texture position.\\n  // First we take Cartesian coordinates.\\n\\n  float y = v_position.x;\\n  float z = v_position.y;\\n  float hyp_squared = y * y + z * z;\\n\\n  // 1. Discard points outside the sphere\\n\\n  if (sqrt(hyp_squared) > 1.) {\\n    discard;\\n  }\\n\\n  // 2. Determine front-facing spherical coordinate\\n\\n  float lambda_offset = tick / 400.;\\n\\n  float x = sqrt(1. - hyp_squared);           // Take positive face\\n  float lambda = atan(y / x) + lambda_offset; // [-PI / 2, PI / 2]\\n  float phi = acos(z);                        // [0, PI]\\n\\n  // 3. Convert long-lat radians to long-lat\\n\\n  float longitude = (lambda + PI) / (2. * PI);\\n  float latitude = phi / PI;\\n\\n  // 3.5. Draw lat/lng lines\\n\\n  // if (mod(longitude, PI / 360.) < 0.001) {\\n  //   gl_FragColor = vec4(0, 0, 0, 0.3);\\n  //   return;\\n  // }\\n\\n  // 4. Grab the texture color and do some color stuffs. Black = land, white =\\n  // no land.\\n\\n  vec2 longlat = vec2(mod(longitude, 1.), mod(latitude, 1.));\\n  vec3 texture_color = texture2D(landTexture, longlat).rgb;\\n  vec3 mono_color = texture2D(monoTexture, longlat).rgb;\\n\\n  texture_color += vec3(240. / 255.) * mono_color;\\n\\n  // 5. Calculate lighting. Allow it to only impact a little bit.\\n\\n  vec3 normal = vec3(y, z, x);\\n  float light = pow(dot(normal, LIGHT_REVERSED) / LIGHT_MAG, 1.);\\n  light = min(1.0, 0.55 + light * 0.3);\\n\\n  gl_FragColor = vec4(texture_color, 1.);\\n  gl_FragColor.rgb *= light;\\n}\\n\";","module.exports=\"precision mediump float;\\n#define GLSLIFY 1\\n\\nuniform vec2 aspectRatio;\\n\\nattribute vec2 position;\\n\\nvarying vec2 v_position;\\n\\nvoid main() {\\n  // For some reason textures only cover the first quadrant of the clip space.\\n  // Remember that v_position should become the coordinate of the texture in\\n  // clip space. Cutting position in half means that (1, 1) in the clip space\\n  // becomes (0.5, 0.5) on the texture.\\n  // two quadrants' worth of space.\\n  // Adding 0.5 to position means that (1, 1) in the clip space becomes (1, 1)\\n  // on the texture, and similarly (0, 0) -> (0.5, 0.5) (the texture's center)\\n  // and (-1, -1) -> (0, 0).\\n\\n  // v_position = 0.5 + position * 0.5;\\n  v_position = position * aspectRatio;\\n\\n  // gl_Position should be position because the position attribute covers the\\n  // whole clip space\\n  gl_Position = vec4(position, 0, 1);\\n}\\n\";","import createREGL from 'regl';\nimport { compute_vertices } from './vertices';\n\nimport borderFrag from './shaders/borders.frag';\nimport borderVert from './shaders/borders.vert';\nimport textureFrag from './shaders/texture.frag';\nimport textureVert from './shaders/texture.vert';\n\nconst regl = createREGL();\n\nconst base =\n  'https://static01.nyt.com/newsgraphics/2020/02/04/coronavirus-flights/67d5b188d41684d2a82da11e94e358b4a769735e';\n\nasync function getVertices() {\n  return fetch(`${base}/geometry/borders.dat`)\n    .then(response => response.arrayBuffer())\n    .then(buffer => compute_vertices(buffer));\n}\n\nasync function getTexture(filename) {\n  return new Promise(resolve => {\n    const image = new Image();\n    image.src = `${base}/textures/${filename}`;\n    image.crossOrigin = '';\n    image.onload = () => resolve(regl.texture(image));\n  });\n}\n\nasync function main() {\n  const [vertices, landTexture, monoTexture] = await Promise.all([getVertices(), getTexture('specularity@2x.png'), getTexture('mono@2x.png')]);\n\n  const drawBorders = regl({\n    frag: borderFrag,\n    vert: borderVert,\n    attributes: {\n      position: vertices,\n    },\n    count: vertices.length / 2,\n    primitive: 'points',\n  });\n\n  const drawTexture = regl({\n    frag: textureFrag,\n    vert: textureVert,\n\n    uniforms: {\n      landTexture,\n      monoTexture,\n      tick: regl.prop('tick'),\n      aspectRatio: ({ viewportWidth, viewportHeight }) => {\n        const ar = viewportWidth / viewportHeight;\n        return ar > 1 ? [ar, 1] : [1, 1 / ar];\n      }\n    },\n    attributes: {\n      // Two triangles that cover the whole clip space\n      position: regl.buffer([\n        [-1, 1],\n        [1, -1],\n        [1, 1],\n        [-1, 1],\n        [1, -1],\n        [-1, -1],\n      ]),\n    },\n\n    count: 6,\n  });\n\n  regl.frame(({ tick }) => {\n    regl.clear({\n      color: [0, 0, 0, 0],\n      depth: 1,\n    });\n    drawBorders();\n    drawTexture({ tick });\n  });\n}\n\nasync function test() {\n  const res = await fetch(`${base}/20200123.dat`);\n  const buf = await res.arrayBuffer();\n  console.log(new Uint16Array(buf));\n}\n\nmain().catch(console.error);\n"]}